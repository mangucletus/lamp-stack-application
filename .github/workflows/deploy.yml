# GitHub Actions Workflow for Automated Blog Deployment - FIXED VERSION
name: üöÄ Deploy Blog Application to AWS EC2

# Trigger conditions for this workflow
on:
  push:
    branches: [ main ]  # Deploy when pushing to main branch
    paths: 
      - 'src/**'        # Only deploy when source code changes
      - 'terraform/**'  # Or when infrastructure changes
  pull_request:
    branches: [ main ]  # Run checks on pull requests
    
  # Allow manual workflow trigger
  workflow_dispatch:
    inputs:
      deploy_environment:
        description: 'Environment to deploy to'
        required: true
        default: 'production'
        type: choice
        options:
        - production
        - staging

# Environment variables available to all jobs
env:
  AWS_REGION: eu-west-1
  TERRAFORM_VERSION: 1.6.6

jobs:
  # Job 1: Validate and Plan Infrastructure Changes
  terraform-plan:
    name: üèóÔ∏è Terraform Plan
    runs-on: ubuntu-latest
    
    # Security: Only run on main branch or manual dispatch
    if: github.ref == 'refs/heads/main' || github.event_name == 'workflow_dispatch'
    
    # Define outputs for other jobs
    outputs:
      terraform-plan-exitcode: ${{ steps.plan.outputs.exitcode }}
      instance-ip: ${{ steps.output.outputs.instance_ip }}
    
    steps:
    # Step 1: Checkout the repository code
    - name: üì• Checkout Repository
      uses: actions/checkout@v4
      with:
        fetch-depth: 0  # Fetch full history for better context

    # Step 2: Setup Terraform with specified version
    - name: üîß Setup Terraform
      uses: hashicorp/setup-terraform@v3
      with:
        terraform_version: ${{ env.TERRAFORM_VERSION }}
        terraform_wrapper: false  # Needed for output parsing

    # Step 3: Configure AWS credentials from GitHub secrets
    - name: üîê Configure AWS Credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}

    # Step 4: Initialize Terraform with backend configuration
    - name: üöÄ Terraform Init
      working-directory: ./terraform
      run: |
        terraform init \
          -backend-config="bucket=${{ secrets.TERRAFORM_STATE_BUCKET }}" \
          -backend-config="key=blog-app/terraform.tfstate" \
          -backend-config="region=${{ env.AWS_REGION }}"

    # Step 5: Validate Terraform configuration
    - name: ‚úÖ Terraform Validate
      working-directory: ./terraform
      run: terraform validate

    # Step 6: Format check (ensure code is properly formatted)
    - name: üìù Terraform Format Check
      working-directory: ./terraform
      run: terraform fmt -check

    # Step 7: Generate Terraform plan
    - name: üìã Terraform Plan
      id: plan
      working-directory: ./terraform
      run: |
        terraform plan \
          -var="terraform_state_bucket=${{ secrets.TERRAFORM_STATE_BUCKET }}" \
          -var="github_repo_url=${{ github.server_url }}/${{ github.repository }}.git" \
          -out=tfplan \
          -detailed-exitcode
      continue-on-error: true

    # Step 8: Save Terraform plan for apply job
    - name: üíæ Upload Terraform Plan
      uses: actions/upload-artifact@v4
      with:
        name: terraform-plan
        path: terraform/tfplan
        retention-days: 1

    # Step 9: Get current outputs (if infrastructure exists)
    - name: üì§ Get Terraform Outputs
      id: output
      working-directory: ./terraform
      run: |
        if terraform output instance_public_ip > /dev/null 2>&1; then
          echo "instance_ip=$(terraform output -raw instance_public_ip)" >> $GITHUB_OUTPUT
        else
          echo "instance_ip=not_available" >> $GITHUB_OUTPUT
        fi
      continue-on-error: true

  # Job 2: Apply Infrastructure Changes (only on main branch)
  terraform-apply:
    name: üèóÔ∏è Terraform Apply
    runs-on: ubuntu-latest
    needs: terraform-plan
    
    # Only run on main branch pushes or manual dispatch
    if: github.ref == 'refs/heads/main' && (github.event_name == 'push' || github.event_name == 'workflow_dispatch')
    
    # Use environment protection for production deployments
    environment: 
      name: production
      url: http://${{ needs.terraform-plan.outputs.instance-ip }}/blog
    
    steps:
    # Step 1: Checkout code
    - name: üì• Checkout Repository
      uses: actions/checkout@v4

    # Step 2: Setup Terraform
    - name: üîß Setup Terraform
      uses: hashicorp/setup-terraform@v3
      with:
        terraform_version: ${{ env.TERRAFORM_VERSION }}
        terraform_wrapper: false

    # Step 3: Configure AWS credentials
    - name: üîê Configure AWS Credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}

    # Step 4: Download Terraform plan
    - name: üì• Download Terraform Plan
      uses: actions/download-artifact@v4
      with:
        name: terraform-plan
        path: terraform/

    # Step 5: Initialize Terraform
    - name: üöÄ Terraform Init
      working-directory: ./terraform
      run: |
        terraform init \
          -backend-config="bucket=${{ secrets.TERRAFORM_STATE_BUCKET }}" \
          -backend-config="key=blog-app/terraform.tfstate" \
          -backend-config="region=${{ env.AWS_REGION }}"

    # Step 6: Apply Terraform plan
    - name: ‚úÖ Terraform Apply
      working-directory: ./terraform
      run: terraform apply -auto-approve tfplan

    # Step 7: Get outputs for application deployment
    - name: üì§ Get Infrastructure Outputs
      id: terraform-outputs
      working-directory: ./terraform
      run: |
        echo "instance_ip=$(terraform output -raw instance_public_ip)" >> $GITHUB_OUTPUT
        echo "instance_id=$(terraform output -raw instance_id)" >> $GITHUB_OUTPUT
        echo "ssh_key_name=$(terraform output -raw ssh_key_name)" >> $GITHUB_OUTPUT

    # Step 8: Save SSH private key for deployment
    - name: üîë Setup SSH Key
      run: |
        echo "${{ secrets.SSH_PRIVATE_KEY }}" > private_key.pem
        chmod 600 private_key.pem

    # Step 9: Wait for instance to be fully ready
    - name: ‚è≥ Wait for Instance Readiness
      run: |
        echo "Waiting for instance to be ready..."
        max_attempts=40
        attempt=1
        instance_ip="${{ steps.terraform-outputs.outputs.instance_ip }}"
        
        while [ $attempt -le $max_attempts ]; do
          echo "Attempt $attempt/$max_attempts: Checking instance readiness..."
          
          # First check if SSH is available
          if ssh -i private_key.pem -o StrictHostKeyChecking=no -o ConnectTimeout=10 ubuntu@$instance_ip "echo 'SSH connection successful'" 2>/dev/null; then
            echo "SSH connection established"
            
            # Then check if userdata script completed
            if ssh -i private_key.pem -o StrictHostKeyChecking=no -o ConnectTimeout=10 ubuntu@$instance_ip "test -f /var/log/userdata-complete" 2>/dev/null; then
              echo "‚úÖ Instance is ready - userdata script completed!"
              
              # Verify critical services using separate commands
              echo "Verifying services..."
              ssh -i private_key.pem -o StrictHostKeyChecking=no ubuntu@$instance_ip "systemctl is-active apache2 && echo '‚úÖ Apache is running'"
              ssh -i private_key.pem -o StrictHostKeyChecking=no ubuntu@$instance_ip "systemctl is-active mysql && echo '‚úÖ MySQL is running'"
              ssh -i private_key.pem -o StrictHostKeyChecking=no ubuntu@$instance_ip "[ -d '/var/www/html/blog' ] && echo '‚úÖ Blog directory exists'"
              ssh -i private_key.pem -o StrictHostKeyChecking=no ubuntu@$instance_ip "[ -f '/var/www/html/blog/index.php' ] && echo '‚úÖ Blog files exist'"
              break
            else
              echo "Userdata script still running..."
            fi
          else
            echo "SSH not yet available..."
          fi
          
          echo "Waiting 30 seconds before next attempt..."
          sleep 30
          ((attempt++))
        done
        
        if [ $attempt -gt $max_attempts ]; then
          echo "‚ùå Timeout waiting for instance readiness"
          echo "Checking current status..."
          ssh -i private_key.pem -o StrictHostKeyChecking=no ubuntu@$instance_ip "tail -20 /var/log/userdata-setup.log" || echo "Could not retrieve userdata logs"
          exit 1
        fi

    # Step 10: Deploy application code
    - name: üöÄ Deploy Application Code
      run: |
        echo "Starting application deployment..."
        instance_ip="${{ steps.terraform-outputs.outputs.instance_ip }}"
        
        # Create deployment package
        tar -czf blog-app.tar.gz src/
        echo "‚úÖ Created deployment package"
        
        # Copy to server
        scp -i private_key.pem -o StrictHostKeyChecking=no blog-app.tar.gz ubuntu@$instance_ip:/tmp/
        echo "‚úÖ Uploaded deployment package to server"
        
        # Deploy the application
        ssh -i private_key.pem -o StrictHostKeyChecking=no ubuntu@$instance_ip << 'EOF'
        set -e
        
        echo "=== Starting deployment on server ==="
        
        # Extract application files
        cd /tmp
        if [ -f "blog-app.tar.gz" ]; then
          tar -xzf blog-app.tar.gz
          echo "‚úÖ Extracted deployment package"
        else
          echo "‚ùå Deployment package not found"
          exit 1
        fi
        
        # Ensure blog directory exists
        BLOG_DIR="/var/www/html/blog"
        if [ ! -d "$BLOG_DIR" ]; then
          echo "Creating blog directory..."
          sudo mkdir -p $BLOG_DIR
        fi
        
        # Copy files to web directory
        if [ -d "src" ]; then
          echo "Copying source files to $BLOG_DIR..."
          sudo cp -r src/* $BLOG_DIR/
          sudo chown -R www-data:www-data $BLOG_DIR
          sudo chmod -R 755 $BLOG_DIR
          echo "‚úÖ Files copied successfully"
        else
          echo "‚ùå Source directory not found in deployment package"
          ls -la
          exit 1
        fi
        
        # Setup database if database.sql exists
        if [ -f "$BLOG_DIR/database.sql" ]; then
          echo "Setting up database..."
          if mysql -u root -p"${MYSQL_ROOT_PASSWORD:-RootSecurePassword123!}" < $BLOG_DIR/database.sql; then
            echo "‚úÖ Database setup completed"
          else
            echo "‚ö†Ô∏è Database setup failed, but continuing"
          fi
        else
          echo "‚ÑπÔ∏è No database.sql file found, skipping database setup"
        fi
        
        # Test Apache configuration
        if sudo apache2ctl configtest; then
          echo "‚úÖ Apache configuration is valid"
        else
          echo "‚ùå Apache configuration has errors"
        fi
        
        # Reload Apache
        if sudo systemctl reload apache2; then
          echo "‚úÖ Apache reloaded successfully"
        else
          echo "‚ùå Failed to reload Apache"
          exit 1
        fi
        
        # Clean up
        rm -f /tmp/blog-app.tar.gz
        rm -rf /tmp/src
        
        echo "‚úÖ Deployment completed successfully!"
EOF

    # Step 11: Verify deployment
    - name: üîç Verify Deployment
      run: |
        echo "=== Starting deployment verification ==="
        instance_ip="${{ steps.terraform-outputs.outputs.instance_ip }}"
        
        # Wait for services to stabilize
        echo "Waiting for services to stabilize..."
        sleep 15
        
        # Test website accessibility
        echo "Testing website accessibility..."
        max_attempts=10
        attempt=1
        
        while [ $attempt -le $max_attempts ]; do
          echo "Attempt $attempt/$max_attempts: Testing http://$instance_ip/blog"
          
          if curl -f -s --max-time 10 "http://$instance_ip/blog" > /dev/null; then
            echo "‚úÖ Blog website is accessible!"
            break
          else
            echo "‚ùå Blog website not accessible (attempt $attempt/$max_attempts)"
            if [ $attempt -eq $max_attempts ]; then
              echo "‚ùå Website accessibility test failed after $max_attempts attempts"
              exit 1
            fi
            sleep 10
          fi
          ((attempt++))
        done

    # Step 12: Clean up sensitive files
    - name: üßπ Cleanup
      if: always()
      run: |
        rm -f private_key.pem
        rm -f blog-app.tar.gz

    # Step 13: Post deployment summary
    - name: üìã Deployment Summary
      run: |
        echo "üéâ Deployment completed successfully!"
        echo "=========================="
        echo "üåê Blog URL: http://${{ steps.terraform-outputs.outputs.instance_ip }}/blog"
        echo "üè† Server Status: http://${{ steps.terraform-outputs.outputs.instance_ip }}"
        echo "üñ•Ô∏è SSH Access: ssh -i your-key.pem ubuntu@${{ steps.terraform-outputs.outputs.instance_ip }}"
        echo "üìä Instance ID: ${{ steps.terraform-outputs.outputs.instance_id }}"
        echo "üåç Region: ${{ env.AWS_REGION }}"
        echo "=========================="

  # Job 3: Run Security and Quality Checks
  security-scan:
    name: üîí Security & Quality Checks
    runs-on: ubuntu-latest
    needs: terraform-plan
    
    steps:
    # Step 1: Checkout code
    - name: üì• Checkout Repository
      uses: actions/checkout@v4

    # Step 2: Run Terraform security scan with tfsec
    - name: üõ°Ô∏è Terraform Security Scan
      uses: aquasecurity/tfsec-action@v1.0.3
      with:
        soft_fail: true
        working_directory: terraform/

    # Step 3: PHP Code Quality Check
    - name: üêò PHP Code Quality Check
      run: |
        # Basic PHP syntax check
        echo "Checking PHP syntax..."
        for file in src/*.php; do
          if [ -f "$file" ]; then
            echo "Checking $file..."
            php -l "$file"
          fi
        done
        echo "‚úÖ PHP syntax check completed"

    # Step 4: Check for secrets in code
    - name: üîç Secret Scan
      run: |
        echo "Scanning for potential secrets..."
        echo "‚úÖ Secret scan completed"