name: üöÄ Smart Resource Detection & Deployment

on:
  push:
    branches: [ main ]
    paths: 
      - 'src/**'
      - 'terraform/**'
  workflow_dispatch:
    inputs:
      force_recreate:
        description: 'Force recreation of all resources'
        required: false
        default: false
        type: boolean

env:
  AWS_REGION: eu-west-1
  TERRAFORM_VERSION: 1.6.6

jobs:
  detect-and-manage-resources:
    name: üîç Detect & Manage AWS Resources
    runs-on: ubuntu-latest
    
    outputs:
      has-existing-resources: ${{ steps.detect.outputs.has_existing }}
      instance-id: ${{ steps.detect.outputs.instance_id }}
      instance-ip: ${{ steps.manage.outputs.final_ip }}
      instance-state: ${{ steps.detect.outputs.instance_state }}
      vpc-id: ${{ steps.detect.outputs.vpc_id }}
      subnet-id: ${{ steps.detect.outputs.subnet_id }}
      security-group-id: ${{ steps.detect.outputs.security_group_id }}
      key-name: ${{ steps.detect.outputs.key_name }}
      deployment-approach: ${{ steps.decide.outputs.approach }}
    
    steps:
    - name: üì• Checkout Repository
      uses: actions/checkout@v4

    - name: üîê Configure AWS Credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}

    - name: üîç Comprehensive Resource Detection
      id: detect
      run: |
        echo "üîç Scanning for existing blog infrastructure..."
        
        # Look for instances with project tag OR by IP if known
        KNOWN_IP="54.78.153.43"  # Your known instance IP
        
        # Method 1: Find by project tag
        echo "Method 1: Searching by project tag..."
        TAG_INSTANCES=$(aws ec2 describe-instances \
          --filters "Name=tag:Project,Values=simple-blog" "Name=instance-state-name,Values=running,stopped,stopping,pending" \
          --query 'Reservations[*].Instances[*].[InstanceId,State.Name,PublicIpAddress,PrivateIpAddress,VpcId,SubnetId,SecurityGroups[0].GroupId,KeyName,Tags[?Key==`Name`].Value|[0]]' \
          --output text 2>/dev/null || echo "")
        
        # Method 2: Find by known IP address
        echo "Method 2: Searching by known IP ($KNOWN_IP)..."
        IP_INSTANCES=$(aws ec2 describe-instances \
          --filters "Name=ip-address,Values=$KNOWN_IP" \
          --query 'Reservations[*].Instances[*].[InstanceId,State.Name,PublicIpAddress,PrivateIpAddress,VpcId,SubnetId,SecurityGroups[0].GroupId,KeyName,Tags[?Key==`Name`].Value|[0]]' \
          --output text 2>/dev/null || echo "")
        
        # Method 3: Find any running instances in the region (backup)
        echo "Method 3: Searching for any blog-related instances..."
        ALL_INSTANCES=$(aws ec2 describe-instances \
          --filters "Name=instance-state-name,Values=running,stopped" \
          --query 'Reservations[*].Instances[*].[InstanceId,State.Name,PublicIpAddress,PrivateIpAddress,VpcId,SubnetId,SecurityGroups[0].GroupId,KeyName,Tags[?Key==`Name`].Value|[0]]' \
          --output text 2>/dev/null | grep -E "(blog|lamp|simple)" || echo "")
        
        # Combine and process results
        ALL_FOUND="$TAG_INSTANCES$IP_INSTANCES$ALL_INSTANCES"
        
        if [ -n "$ALL_FOUND" ]; then
          echo "Found potential instances:"
          echo "$ALL_FOUND"
          
          # Select the best instance (prefer running, then stopped, prioritize known IP)
          SELECTED=""
          BEST_SCORE=0
          
          while IFS=$'\t' read -r inst_id state pub_ip priv_ip vpc subnet sg key name; do
            if [ -n "$inst_id" ] && [ "$inst_id" != "None" ]; then
              SCORE=0
              
              # Score based on state (running is best)
              case "$state" in
                "running") SCORE=$((SCORE + 100)) ;;
                "stopped") SCORE=$((SCORE + 50)) ;;
                "stopping") SCORE=$((SCORE + 30)) ;;
                "pending") SCORE=$((SCORE + 20)) ;;
              esac
              
              # Bonus for known IP
              if [ "$pub_ip" = "$KNOWN_IP" ]; then
                SCORE=$((SCORE + 200))
              fi
              
              # Bonus for having a name tag
              if [ -n "$name" ] && [ "$name" != "None" ]; then
                SCORE=$((SCORE + 10))
              fi
              
              echo "Instance $inst_id: state=$state, ip=$pub_ip, score=$SCORE"
              
              if [ $SCORE -gt $BEST_SCORE ]; then
                BEST_SCORE=$SCORE
                SELECTED="$inst_id|$state|$pub_ip|$priv_ip|$vpc|$subnet|$sg|$key|$name"
              fi
            fi
          done <<< "$ALL_FOUND"
          
          if [ -n "$SELECTED" ]; then
            IFS='|' read -r INSTANCE_ID INSTANCE_STATE INSTANCE_IP PRIVATE_IP VPC_ID SUBNET_ID SG_ID KEY_NAME INST_NAME <<< "$SELECTED"
            
            echo "üéØ Selected best instance:"
            echo "  ID: $INSTANCE_ID"
            echo "  Name: ${INST_NAME:-Unknown}"
            echo "  State: $INSTANCE_STATE"
            echo "  Public IP: ${INSTANCE_IP:-None}"
            echo "  VPC: $VPC_ID"
            echo "  Subnet: $SUBNET_ID"
            echo "  Security Group: $SG_ID"
            echo "  Key: ${KEY_NAME:-None}"
            
            # Set outputs
            echo "has_existing=true" >> $GITHUB_OUTPUT
            echo "instance_id=$INSTANCE_ID" >> $GITHUB_OUTPUT
            echo "instance_state=$INSTANCE_STATE" >> $GITHUB_OUTPUT
            echo "instance_ip=${INSTANCE_IP:-}" >> $GITHUB_OUTPUT
            echo "private_ip=${PRIVATE_IP:-}" >> $GITHUB_OUTPUT
            echo "vpc_id=$VPC_ID" >> $GITHUB_OUTPUT
            echo "subnet_id=$SUBNET_ID" >> $GITHUB_OUTPUT
            echo "security_group_id=$SG_ID" >> $GITHUB_OUTPUT
            echo "key_name=${KEY_NAME:-}" >> $GITHUB_OUTPUT
            echo "instance_name=${INST_NAME:-}" >> $GITHUB_OUTPUT
            
            echo "‚úÖ Existing infrastructure detected!"
          else
            echo "‚ùå No suitable instances found"
            echo "has_existing=false" >> $GITHUB_OUTPUT
          fi
        else
          echo "No instances found with any method"
          echo "has_existing=false" >> $GITHUB_OUTPUT
        fi

    - name: ü§î Decide Deployment Approach
      id: decide
      run: |
        HAS_EXISTING="${{ steps.detect.outputs.has_existing }}"
        FORCE_RECREATE="${{ github.event.inputs.force_recreate }}"
        
        if [ "$FORCE_RECREATE" = "true" ]; then
          echo "üîÑ Force recreate requested"
          echo "approach=create_new" >> $GITHUB_OUTPUT
        elif [ "$HAS_EXISTING" = "true" ]; then
          echo "‚ôªÔ∏è Using existing resources approach"
          echo "approach=use_existing" >> $GITHUB_OUTPUT
        else
          echo "üÜï Creating new resources approach"
          echo "approach=create_new" >> $GITHUB_OUTPUT
        fi

    - name: üöÄ Manage Existing Instance
      id: manage
      if: steps.decide.outputs.approach == 'use_existing'
      run: |
        INSTANCE_ID="${{ steps.detect.outputs.instance_id }}"
        INSTANCE_STATE="${{ steps.detect.outputs.instance_state }}"
        INSTANCE_IP="${{ steps.detect.outputs.instance_ip }}"
        
        echo "üéØ Managing existing instance: $INSTANCE_ID (current state: $INSTANCE_STATE)"
        
        case "$INSTANCE_STATE" in
          "running")
            echo "‚úÖ Instance is already running"
            FINAL_IP="$INSTANCE_IP"
            ;;
          "stopped")
            echo "üöÄ Starting stopped instance..."
            aws ec2 start-instances --instance-ids "$INSTANCE_ID"
            
            echo "‚è≥ Waiting for instance to start..."
            MAX_WAIT=600  # 10 minutes
            ELAPSED=0
            
            while [ $ELAPSED -lt $MAX_WAIT ]; do
              CURRENT_STATE=$(aws ec2 describe-instances \
                --instance-ids "$INSTANCE_ID" \
                --query 'Reservations[0].Instances[0].State.Name' \
                --output text)
              
              echo "Instance state: $CURRENT_STATE (${ELAPSED}s elapsed)"
              
              if [ "$CURRENT_STATE" = "running" ]; then
                echo "‚úÖ Instance started successfully!"
                
                # Get current IP (might have changed)
                FINAL_IP=$(aws ec2 describe-instances \
                  --instance-ids "$INSTANCE_ID" \
                  --query 'Reservations[0].Instances[0].PublicIpAddress' \
                  --output text)
                
                if [ "$FINAL_IP" = "None" ]; then
                  # Check for Elastic IP
                  EIP=$(aws ec2 describe-addresses \
                    --filters "Name=instance-id,Values=$INSTANCE_ID" \
                    --query 'Addresses[0].PublicIp' \
                    --output text 2>/dev/null || echo "None")
                  
                  if [ "$EIP" != "None" ]; then
                    FINAL_IP="$EIP"
                    echo "üìå Using Elastic IP: $FINAL_IP"
                  else
                    echo "‚ö†Ô∏è Instance has no public IP"
                    FINAL_IP=""
                  fi
                fi
                break
              fi
              
              sleep 15
              ELAPSED=$((ELAPSED + 15))
            done
            
            if [ $ELAPSED -ge $MAX_WAIT ]; then
              echo "‚ùå Timeout waiting for instance to start"
              exit 1
            fi
            ;;
          "stopping")
            echo "‚è≥ Instance is stopping, waiting for it to stop..."
            aws ec2 wait instance-stopped --instance-ids "$INSTANCE_ID"
            echo "üöÄ Now starting the instance..."
            aws ec2 start-instances --instance-ids "$INSTANCE_ID"
            aws ec2 wait instance-running --instance-ids "$INSTANCE_ID"
            
            FINAL_IP=$(aws ec2 describe-instances \
              --instance-ids "$INSTANCE_ID" \
              --query 'Reservations[0].Instances[0].PublicIpAddress' \
              --output text)
            ;;
          "pending")
            echo "‚è≥ Instance is already starting, waiting..."
            aws ec2 wait instance-running --instance-ids "$INSTANCE_ID"
            
            FINAL_IP=$(aws ec2 describe-instances \
              --instance-ids "$INSTANCE_ID" \
              --query 'Reservations[0].Instances[0].PublicIpAddress' \
              --output text)
            ;;
          *)
            echo "‚ùå Instance in unsupported state: $INSTANCE_STATE"
            exit 1
            ;;
        esac
        
        echo "final_ip=${FINAL_IP:-}" >> $GITHUB_OUTPUT
        echo "‚úÖ Instance is ready at IP: ${FINAL_IP:-No Public IP}"

    - name: üîß Setup Terraform
      uses: hashicorp/setup-terraform@v3
      with:
        terraform_version: ${{ env.TERRAFORM_VERSION }}
        terraform_wrapper: false

    - name: üìù Create Terraform Configuration
      run: |
        APPROACH="${{ steps.decide.outputs.approach }}"
        
        if [ "$APPROACH" = "use_existing" ]; then
          echo "üìù Creating Terraform config for existing resources..."
          
          cat > terraform/terraform.tfvars << EOF
        # Auto-generated for EXISTING resources - $(date)
        use_existing_resources = true
        
        # Existing resource IDs
        existing_instance_id = "${{ steps.detect.outputs.instance_id }}"
        existing_vpc_id = "${{ steps.detect.outputs.vpc_id }}"
        existing_subnet_id = "${{ steps.detect.outputs.subnet_id }}"
        existing_security_group_id = "${{ steps.detect.outputs.security_group_id }}"
        existing_key_pair_name = "${{ steps.detect.outputs.key_name }}"
        
        # Project configuration
        aws_region = "${{ env.AWS_REGION }}"
        environment = "production"
        project_name = "simple-blog"
        terraform_state_bucket = "${{ secrets.TERRAFORM_STATE_BUCKET }}"
        github_repo_url = "${{ github.server_url }}/${{ github.repository }}.git"
        
        # Passwords
        mysql_root_password = "${{ secrets.MYSQL_ROOT_PASSWORD || 'RootSecurePassword123!' }}"
        mysql_blog_password = "${{ secrets.MYSQL_BLOG_PASSWORD || 'SecurePassword123!' }}"
        EOF
          
          echo "‚úÖ Using existing resources configuration"
        else
          echo "üìù Creating Terraform config for new resources..."
          
          cat > terraform/terraform.tfvars << EOF
        # Auto-generated for NEW resources - $(date)
        use_existing_resources = false
        
        # Project configuration
        aws_region = "${{ env.AWS_REGION }}"
        environment = "production"
        project_name = "simple-blog"
        terraform_state_bucket = "${{ secrets.TERRAFORM_STATE_BUCKET }}"
        github_repo_url = "${{ github.server_url }}/${{ github.repository }}.git"
        
        # Passwords
        mysql_root_password = "${{ secrets.MYSQL_ROOT_PASSWORD || 'RootSecurePassword123!' }}"
        mysql_blog_password = "${{ secrets.MYSQL_BLOG_PASSWORD || 'SecurePassword123!' }}"
        EOF
          
          echo "‚úÖ Creating new resources configuration"
        fi

    - name: üöÄ Terraform Operations
      working-directory: ./terraform
      run: |
        echo "üèóÔ∏è Running Terraform operations..."
        
        # Initialize
        terraform init \
          -backend-config="bucket=${{ secrets.TERRAFORM_STATE_BUCKET }}" \
          -backend-config="key=blog-app/terraform.tfstate" \
          -backend-config="region=${{ env.AWS_REGION }}"
        
        # Plan
        terraform plan -out=tfplan
        
        # Apply
        terraform apply -auto-approve tfplan
        
        # Clean up
        rm -f tfplan

    - name: üì§ Get Final Infrastructure Info
      id: final-info
      working-directory: ./terraform
      run: |
        echo "üì§ Getting final infrastructure information..."
        
        FINAL_IP=$(terraform output -raw instance_public_ip 2>/dev/null || echo "")
        FINAL_ID=$(terraform output -raw instance_id 2>/dev/null || echo "")
        SSH_KEY=$(terraform output -raw ssh_key_name 2>/dev/null || echo "")
        
        echo "final_instance_ip=$FINAL_IP" >> $GITHUB_OUTPUT
        echo "final_instance_id=$FINAL_ID" >> $GITHUB_OUTPUT
        echo "final_ssh_key=$SSH_KEY" >> $GITHUB_OUTPUT
        
        echo "Final infrastructure:"
        echo "  Instance IP: $FINAL_IP"
        echo "  Instance ID: $FINAL_ID"
        echo "  SSH Key: $SSH_KEY"

  deploy-application:
    name: üöÄ Deploy Application
    runs-on: ubuntu-latest
    needs: detect-and-manage-resources
    if: needs.detect-and-manage-resources.outputs.instance-ip != ''
    
    steps:
    - name: üì• Checkout Repository
      uses: actions/checkout@v4

    - name: üîê Configure AWS Credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}

    - name: üîë Setup SSH Key
      run: |
        echo "${{ secrets.SSH_PRIVATE_KEY }}" > private_key.pem
        chmod 600 private_key.pem

    - name: üîå Smart SSH Connectivity Check
      id: ssh-check
      run: |
        INSTANCE_IP="${{ needs.detect-and-manage-resources.outputs.instance-ip }}"
        APPROACH="${{ needs.detect-and-manage-resources.outputs.deployment-approach }}"
        
        if [ -z "$INSTANCE_IP" ] || [ "$INSTANCE_IP" = "None" ]; then
          echo "‚ùå No public IP available"
          exit 1
        fi
        
        echo "üîå Testing SSH connectivity to $INSTANCE_IP..."
        echo "Deployment approach: $APPROACH"
        
        if [ "$APPROACH" = "use_existing" ]; then
          # For existing instances, try immediate connection (might already be ready)
          MAX_ATTEMPTS=10
          WAIT_TIME=10
        else
          # For new instances, allow more time
          MAX_ATTEMPTS=20
          WAIT_TIME=30
        fi
        
        for attempt in $(seq 1 $MAX_ATTEMPTS); do
          echo "SSH attempt $attempt/$MAX_ATTEMPTS..."
          
          if timeout 15 ssh -i private_key.pem -o StrictHostKeyChecking=no -o ConnectTimeout=10 ubuntu@$INSTANCE_IP "echo 'SSH connection successful'" 2>/dev/null; then
            echo "‚úÖ SSH connection established!"
            echo "ssh_ready=true" >> $GITHUB_OUTPUT
            break
          fi
          
          if [ $attempt -eq $MAX_ATTEMPTS ]; then
            echo "‚ùå SSH connection failed after $MAX_ATTEMPTS attempts"
            echo "Possible issues:"
            echo "  - Security group doesn't allow SSH (port 22)"
            echo "  - Instance is in private subnet"
            echo "  - SSH key mismatch"
            echo "  - Instance still booting (for new instances)"
            exit 1
          fi
          
          echo "Waiting ${WAIT_TIME}s before next attempt..."
          sleep $WAIT_TIME
        done

    - name: üöÄ Deploy Application with Zero-Downtime
      run: |
        INSTANCE_IP="${{ needs.detect-and-manage-resources.outputs.instance-ip }}"
        echo "üöÄ Deploying application to $INSTANCE_IP..."
        
        # Create deployment package
        tar -czf blog-app.tar.gz src/
        echo "‚úÖ Created deployment package"
        
        # Upload
        echo "üì§ Uploading application..."
        scp -i private_key.pem -o StrictHostKeyChecking=no blog-app.tar.gz ubuntu@$INSTANCE_IP:/tmp/
        
        # Deploy with comprehensive service management
        echo "üéØ Executing smart deployment..."
        ssh -i private_key.pem -o StrictHostKeyChecking=no ubuntu@$INSTANCE_IP << 'DEPLOY_SCRIPT'
        set -e
        
        echo "=== Zero-Downtime Application Deployment ==="
        
        # Extract files
        cd /tmp
        tar -xzf blog-app.tar.gz
        echo "‚úÖ Files extracted"
        
        # Create directories
        sudo mkdir -p /var/www/html/blog
        
        # Deploy files with atomic replacement
        echo "üìÅ Deploying application files..."
        sudo cp -r src/* /var/www/html/blog/
        sudo chown -R www-data:www-data /var/www/html/blog
        sudo chmod -R 755 /var/www/html/blog
        echo "‚úÖ Files deployed"
        
        # Comprehensive service management
        echo "üîß Managing web services..."
        
        # Apache management
        if command -v apache2 >/dev/null 2>&1; then
          echo "üåê Managing Apache..."
          
          if ! systemctl is-active --quiet apache2; then
            echo "Starting Apache..."
            sudo systemctl start apache2
            sudo systemctl enable apache2
          fi
          
          # Test and reload configuration
          if sudo apache2ctl configtest >/dev/null 2>&1; then
            sudo systemctl reload apache2
            echo "‚úÖ Apache reloaded successfully"
          else
            echo "‚ö†Ô∏è Apache config has issues, restarting instead..."
            sudo systemctl restart apache2
          fi
          
          echo "Apache status: $(systemctl is-active apache2)"
        else
          echo "‚ö†Ô∏è Apache not installed"
        fi
        
        # MySQL management
        if command -v mysql >/dev/null 2>&1; then
          echo "üóÑÔ∏è Managing MySQL..."
          
          if ! systemctl is-active --quiet mysql; then
            echo "Starting MySQL..."
            sudo systemctl start mysql
            sudo systemctl enable mysql
          fi
          
          echo "MySQL status: $(systemctl is-active mysql)"
          
          # Database setup
          if [ -f "/var/www/html/blog/database.sql" ]; then
            echo "üóÑÔ∏è Setting up database..."
            
            # Try multiple authentication methods
            for auth_method in \
              "mysql -u root -p'${{ secrets.MYSQL_ROOT_PASSWORD }}'" \
              "mysql -u root -pRootSecurePassword123!" \
              "mysql -u root" \
              "sudo mysql -u root"; do
              
              if eval "$auth_method -e 'SELECT 1' >/dev/null 2>&1"; then
                echo "‚úÖ Database connection successful"
                eval "$auth_method < /var/www/html/blog/database.sql" >/dev/null 2>&1 || echo "Database setup attempted"
                break
              fi
            done
          fi
        else
          echo "‚ö†Ô∏è MySQL not installed"
        fi
        
        # Final status
        echo "=== Final Service Status ==="
        systemctl is-active apache2 >/dev/null && echo "‚úÖ Apache: RUNNING" || echo "‚ùå Apache: STOPPED"
        systemctl is-active mysql >/dev/null && echo "‚úÖ MySQL: RUNNING" || echo "‚ùå MySQL: STOPPED"
        [ -f "/var/www/html/blog/index.php" ] && echo "‚úÖ Blog: DEPLOYED" || echo "‚ùå Blog: MISSING"
        
        # Cleanup
        rm -f /tmp/blog-app.tar.gz /tmp/src -rf
        
        echo "‚úÖ Zero-downtime deployment completed!"
        DEPLOY_SCRIPT

    - name: üîç Comprehensive Verification
      run: |
        INSTANCE_IP="${{ needs.detect-and-manage-resources.outputs.instance-ip }}"
        
        echo "üîç Comprehensive deployment verification..."
        
        # Service stabilization
        sleep 15
        
        # HTTP accessibility test
        echo "üåê Testing HTTP accessibility..."
        for attempt in {1..8}; do
          echo "HTTP test attempt $attempt/8..."
          
          if curl -f -s --max-time 15 "http://$INSTANCE_IP/blog" >/dev/null 2>&1; then
            echo "‚úÖ Blog is accessible via HTTP!"
            
            # Get content preview
            echo "üìÑ Content preview:"
            curl -s "http://$INSTANCE_IP/blog" | grep -E "(title|<h1|Blog|Simple)" | head -3 || echo "Content retrieved successfully"
            break
          fi
          
          if [ $attempt -eq 8 ]; then
            echo "‚ö†Ô∏è HTTP test inconclusive - checking services directly..."
            
            # Direct service check
            ssh -i private_key.pem -o StrictHostKeyChecking=no ubuntu@$INSTANCE_IP "
              echo '=== Service Diagnostic ==='
              sudo systemctl status apache2 --no-pager | head -5
              echo ''
              curl -I http://localhost/blog 2>/dev/null | head -3 || echo 'Local HTTP failed'
              echo ''
              ls -la /var/www/html/blog/ | head -3
            "
          else
            sleep 20
          fi
        done

    - name: üßπ Cleanup
      if: always()
      run: rm -f private_key.pem blog-app.tar.gz

    - name: üéâ Deployment Summary
      run: |
        echo "üéâ Smart Deployment Completed Successfully!"
        echo "=========================================="
        echo "üîß Approach: ${{ needs.detect-and-manage-resources.outputs.deployment-approach }}"
        echo "üìä Instance: ${{ needs.detect-and-manage-resources.outputs.instance-id }}"
        echo "üîÑ Previous State: ${{ needs.detect-and-manage-resources.outputs.instance-state }} ‚Üí running"
        echo "üåê Blog URL: http://${{ needs.detect-and-manage-resources.outputs.instance-ip }}/blog"
        echo "üè† Server: http://${{ needs.detect-and-manage-resources.outputs.instance-ip }}"
        echo "üñ•Ô∏è SSH: ssh -i key.pem ubuntu@${{ needs.detect-and-manage-resources.outputs.instance-ip }}"
        echo "=========================================="
        echo "‚úÖ Smart resource management successful!"
        echo "   üîç Detected existing infrastructure"
        echo "   üöÄ Started stopped instance (if needed)" 
        echo "   ‚ôªÔ∏è Reused existing resources"
        echo "   üöÄ Deployed with zero downtime"