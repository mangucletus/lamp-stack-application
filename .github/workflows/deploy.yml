name: ğŸš€ Smart AWS Resource Manager

on:
  push:
    branches: [ main ]
    paths: 
      - 'src/**'
      - 'terraform/**'
  workflow_dispatch:
    inputs:
      action:
        description: 'Action to perform'
        required: true
        default: 'smart-deploy'
        type: choice
        options:
        - smart-deploy
        - force-new-resources
        - start-existing-only

env:
  AWS_REGION: eu-west-1
  TERRAFORM_VERSION: 1.6.6

jobs:
  smart-resource-management:
    name: ğŸ§  Smart Resource Management
    runs-on: ubuntu-latest
    
    outputs:
      instance-id: ${{ steps.discover.outputs.instance_id }}
      instance-ip: ${{ steps.discover.outputs.instance_ip }}
      instance-state: ${{ steps.discover.outputs.instance_state }}
      use-existing: ${{ steps.discover.outputs.use_existing }}
    
    steps:
    - name: ğŸ“¥ Checkout Repository
      uses: actions/checkout@v4

    - name: ğŸ” Configure AWS Credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}

    - name: ğŸ” Discover Existing Infrastructure
      id: discover
      run: |
        echo "ğŸ” Discovering existing blog infrastructure..."
        
        # Look for instances with project tag
        INSTANCES_DATA=$(aws ec2 describe-instances \
          --filters "Name=tag:Project,Values=simple-blog" \
          --query 'Reservations[*].Instances[*].[InstanceId,State.Name,PublicIpAddress,PrivateIpAddress,VpcId,SubnetId,SecurityGroups[0].GroupId,KeyName,Tags[?Key==`Name`].Value|[0]]' \
          --output text 2>/dev/null || echo "")
        
        if [ -n "$INSTANCES_DATA" ] && [ "${{ github.event.inputs.action }}" != "force-new-resources" ]; then
          echo "Found existing blog infrastructure:"
          echo "$INSTANCES_DATA"
          
          # Select the best instance (prefer running, then stopped)
          SELECTED_INSTANCE=""
          while IFS=$'\t' read -r inst_id state pub_ip priv_ip vpc subnet sg key name; do
            if [ -n "$inst_id" ]; then
              echo "Instance: $inst_id ($name) - State: $state"
              
              # Prefer running instances first, then stopped
              if [ "$state" = "running" ] && [ -z "$SELECTED_INSTANCE" ]; then
                SELECTED_INSTANCE="$inst_id|$state|$pub_ip|$priv_ip|$vpc|$subnet|$sg|$key|$name"
              elif [ "$state" = "stopped" ] && [ -z "$SELECTED_INSTANCE" ]; then
                SELECTED_INSTANCE="$inst_id|$state|$pub_ip|$priv_ip|$vpc|$subnet|$sg|$key|$name"
              fi
            fi
          done <<< "$INSTANCES_DATA"
          
          if [ -n "$SELECTED_INSTANCE" ]; then
            IFS='|' read -r INSTANCE_ID INSTANCE_STATE INSTANCE_IP PRIV_IP VPC_ID SUBNET_ID SG_ID KEY_NAME INST_NAME <<< "$SELECTED_INSTANCE"
            
            echo "Selected instance: $INSTANCE_ID ($INST_NAME)"
            echo "Current state: $INSTANCE_STATE"
            echo "Public IP: ${INSTANCE_IP:-None}"
            
            # Set outputs
            echo "use_existing=true" >> $GITHUB_OUTPUT
            echo "instance_id=$INSTANCE_ID" >> $GITHUB_OUTPUT
            echo "instance_state=$INSTANCE_STATE" >> $GITHUB_OUTPUT
            echo "instance_ip=${INSTANCE_IP:-}" >> $GITHUB_OUTPUT
            echo "vpc_id=$VPC_ID" >> $GITHUB_OUTPUT
            echo "subnet_id=$SUBNET_ID" >> $GITHUB_OUTPUT
            echo "security_group_id=$SG_ID" >> $GITHUB_OUTPUT
            echo "key_name=$KEY_NAME" >> $GITHUB_OUTPUT
            
            echo "âœ… Will use existing infrastructure"
          else
            echo "âŒ No suitable existing instances found"
            echo "use_existing=false" >> $GITHUB_OUTPUT
          fi
        else
          echo "No existing instances found or forced new resource creation"
          echo "use_existing=false" >> $GITHUB_OUTPUT
        fi

    - name: ğŸš€ Start Stopped Instance
      if: steps.discover.outputs.use_existing == 'true' && steps.discover.outputs.instance_state == 'stopped'
      id: start-instance
      run: |
        INSTANCE_ID="${{ steps.discover.outputs.instance_id }}"
        echo "ğŸš€ Starting stopped instance: $INSTANCE_ID"
        
        # Start the instance
        aws ec2 start-instances --instance-ids "$INSTANCE_ID"
        
        echo "â³ Waiting for instance to start..."
        
        # Wait for instance to be running (max 10 minutes)
        timeout=600
        elapsed=0
        while [ $elapsed -lt $timeout ]; do
          STATE=$(aws ec2 describe-instances \
            --instance-ids "$INSTANCE_ID" \
            --query 'Reservations[0].Instances[0].State.Name' \
            --output text)
          
          echo "Instance state: $STATE (${elapsed}s elapsed)"
          
          if [ "$STATE" = "running" ]; then
            echo "âœ… Instance is now running!"
            
            # Get the public IP
            PUBLIC_IP=$(aws ec2 describe-instances \
              --instance-ids "$INSTANCE_ID" \
              --query 'Reservations[0].Instances[0].PublicIpAddress' \
              --output text)
            
            echo "instance_ip=${PUBLIC_IP:-}" >> $GITHUB_OUTPUT
            echo "âœ… Instance IP: ${PUBLIC_IP:-None}"
            break
          elif [ "$STATE" = "pending" ]; then
            echo "Instance is starting..."
          else
            echo "âŒ Unexpected instance state: $STATE"
            exit 1
          fi
          
          sleep 15
          elapsed=$((elapsed + 15))
        done
        
        if [ $elapsed -ge $timeout ]; then
          echo "âŒ Timeout waiting for instance to start"
          exit 1
        fi

    - name: ğŸ”§ Setup Terraform
      uses: hashicorp/setup-terraform@v3
      with:
        terraform_version: ${{ env.TERRAFORM_VERSION }}
        terraform_wrapper: false

    - name: ğŸ“ Create Terraform Configuration
      run: |
        echo "ğŸ“ Creating Terraform configuration..."
        
        # Determine final instance IP
        FINAL_IP="${{ steps.start-instance.outputs.instance_ip || steps.discover.outputs.instance_ip }}"
        
        if [ "${{ steps.discover.outputs.use_existing }}" = "true" ]; then
          cat > terraform/terraform.tfvars << EOF
        # Auto-generated for existing resources
        use_existing_resources = true
        existing_instance_id = "${{ steps.discover.outputs.instance_id }}"
        existing_vpc_id = "${{ steps.discover.outputs.vpc_id }}"
        existing_subnet_id = "${{ steps.discover.outputs.subnet_id }}"
        existing_security_group_id = "${{ steps.discover.outputs.security_group_id }}"
        existing_key_pair_name = "${{ steps.discover.outputs.key_name }}"
        
        # Project configuration
        aws_region = "${{ env.AWS_REGION }}"
        environment = "production"
        project_name = "simple-blog"
        terraform_state_bucket = "${{ secrets.TERRAFORM_STATE_BUCKET }}"
        github_repo_url = "${{ github.server_url }}/${{ github.repository }}.git"
        EOF
          echo "âœ… Created configuration for existing resources"
        else
          cat > terraform/terraform.tfvars << EOF
        # Auto-generated for new resources
        use_existing_resources = false
        
        # Project configuration
        aws_region = "${{ env.AWS_REGION }}"
        environment = "production"
        project_name = "simple-blog"
        terraform_state_bucket = "${{ secrets.TERRAFORM_STATE_BUCKET }}"
        github_repo_url = "${{ github.server_url }}/${{ github.repository }}.git"
        EOF
          echo "âœ… Created configuration for new resources"
        fi

    - name: ğŸš€ Terraform Init
      working-directory: ./terraform
      run: |
        terraform init \
          -backend-config="bucket=${{ secrets.TERRAFORM_STATE_BUCKET }}" \
          -backend-config="key=blog-app/terraform.tfstate" \
          -backend-config="region=${{ env.AWS_REGION }}"

    - name: ğŸ“‹ Terraform Plan
      working-directory: ./terraform
      run: terraform plan -out=tfplan

    - name: âœ… Terraform Apply
      working-directory: ./terraform
      run: terraform apply -auto-approve tfplan

    - name: ğŸ“¤ Get Infrastructure Outputs
      id: terraform-outputs
      working-directory: ./terraform
      run: |
        echo "instance_ip=$(terraform output -raw instance_public_ip)" >> $GITHUB_OUTPUT
        echo "instance_id=$(terraform output -raw instance_id)" >> $GITHUB_OUTPUT
        echo "ssh_key_name=$(terraform output -raw ssh_key_name)" >> $GITHUB_OUTPUT

  deploy-application:
    name: ğŸš€ Deploy Application
    runs-on: ubuntu-latest
    needs: smart-resource-management
    if: needs.smart-resource-management.outputs.instance-ip != ''
    
    steps:
    - name: ğŸ“¥ Checkout Repository
      uses: actions/checkout@v4

    - name: ğŸ” Configure AWS Credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}

    - name: ğŸ”‘ Setup SSH Key
      run: |
        echo "${{ secrets.SSH_PRIVATE_KEY }}" > private_key.pem
        chmod 600 private_key.pem

    - name: ğŸ”Œ Wait for SSH Connectivity
      run: |
        INSTANCE_IP="${{ needs.smart-resource-management.outputs.instance-ip }}"
        
        if [ -z "$INSTANCE_IP" ] || [ "$INSTANCE_IP" = "None" ]; then
          echo "âŒ No public IP available for SSH"
          exit 1
        fi
        
        echo "ğŸ”Œ Testing SSH connectivity to $INSTANCE_IP..."
        
        max_attempts=15
        attempt=1
        
        while [ $attempt -le $max_attempts ]; do
          echo "Attempt $attempt/$max_attempts: Testing SSH..."
          
          if timeout 10 ssh -i private_key.pem -o StrictHostKeyChecking=no -o ConnectTimeout=5 ubuntu@$INSTANCE_IP "echo 'SSH ready'" 2>/dev/null; then
            echo "âœ… SSH connection established!"
            break
          fi
          
          if [ $attempt -eq $max_attempts ]; then
            echo "âŒ SSH connection failed after $max_attempts attempts"
            echo "This could mean:"
            echo "  - Instance is still starting up"
            echo "  - Security group doesn't allow SSH"
            echo "  - Instance is in private subnet"
            echo "  - SSH key mismatch"
            exit 1
          fi
          
          sleep 15
          ((attempt++))
        done

    - name: ğŸš€ Deploy Application with Smart Service Management
      run: |
        INSTANCE_IP="${{ needs.smart-resource-management.outputs.instance-ip }}"
        echo "ğŸš€ Deploying application to $INSTANCE_IP..."
        
        # Create deployment package
        tar -czf blog-app.tar.gz src/
        echo "âœ… Created deployment package"
        
        # Upload deployment package
        echo "ğŸ“¤ Uploading application files..."
        scp -i private_key.pem -o StrictHostKeyChecking=no blog-app.tar.gz ubuntu@$INSTANCE_IP:/tmp/
        echo "âœ… Upload completed"
        
        # Deploy with smart service management
        echo "ğŸ¯ Deploying with smart service management..."
        ssh -i private_key.pem -o StrictHostKeyChecking=no ubuntu@$INSTANCE_IP << 'EOF'
        set -e
        
        echo "=== Smart Application Deployment ==="
        
        # Extract deployment package
        cd /tmp
        if [ -f "blog-app.tar.gz" ]; then
          tar -xzf blog-app.tar.gz
          echo "âœ… Deployment package extracted"
        else
          echo "âŒ Deployment package not found"
          exit 1
        fi
        
        # Create blog directory
        BLOG_DIR="/var/www/html/blog"
        sudo mkdir -p "$BLOG_DIR"
        
        # Deploy application files
        if [ -d "src" ]; then
          echo "ğŸ“ Deploying files to $BLOG_DIR..."
          sudo cp -r src/* "$BLOG_DIR/"
          sudo chown -R www-data:www-data "$BLOG_DIR"
          sudo chmod -R 755 "$BLOG_DIR"
          echo "âœ… Application files deployed"
        else
          echo "âŒ Source directory not found"
          exit 1
        fi
        
        # Smart Apache management
        echo "ğŸŒ Managing Apache service..."
        if command -v apache2 >/dev/null 2>&1; then
          if ! systemctl is-active --quiet apache2; then
            echo "ğŸš€ Starting Apache..."
            sudo systemctl start apache2
            sudo systemctl enable apache2
          else
            echo "ğŸ”„ Reloading Apache configuration..."
            sudo systemctl reload apache2
          fi
          
          # Verify Apache configuration
          if sudo apache2ctl configtest >/dev/null 2>&1; then
            echo "âœ… Apache configuration is valid"
          else
            echo "âš ï¸ Apache configuration has warnings"
          fi
          
          echo "âœ… Apache: $(systemctl is-active apache2)"
        else
          echo "âš ï¸ Apache not found - may need manual installation"
        fi
        
        # Smart MySQL management
        echo "ğŸ—„ï¸ Managing MySQL service..."
        if command -v mysql >/dev/null 2>&1; then
          if ! systemctl is-active --quiet mysql; then
            echo "ğŸš€ Starting MySQL..."
            sudo systemctl start mysql
            sudo systemctl enable mysql
          else
            echo "âœ… MySQL already running"
          fi
          echo "âœ… MySQL: $(systemctl is-active mysql)"
          
          # Smart database setup
          if [ -f "$BLOG_DIR/database.sql" ]; then
            echo "ğŸ—„ï¸ Setting up database..."
            
            # Try multiple authentication methods
            DB_SETUP_SUCCESS=false
            for MYSQL_CMD in \
              "mysql -u root -p'${{ secrets.MYSQL_ROOT_PASSWORD }}'" \
              "mysql -u root -pRootSecurePassword123!" \
              "mysql -u root" \
              "sudo mysql"; do
              
              echo "Trying: ${MYSQL_CMD%% *}..."
              if eval "$MYSQL_CMD -e 'SELECT 1' >/dev/null 2>&1"; then
                echo "âœ… Database connection successful"
                eval "$MYSQL_CMD < $BLOG_DIR/database.sql" >/dev/null 2>&1 || echo "Database setup attempted"
                DB_SETUP_SUCCESS=true
                break
              fi
            done
            
            if [ "$DB_SETUP_SUCCESS" = "false" ]; then
              echo "âš ï¸ Could not connect to database - manual setup may be required"
            fi
          fi
        else
          echo "âš ï¸ MySQL not found - may need manual installation"
        fi
        
        # Final status check
        echo "=== Final Service Status ==="
        if command -v apache2 >/dev/null; then
          systemctl is-active --quiet apache2 && echo "âœ… Apache: ACTIVE" || echo "âŒ Apache: INACTIVE"
        fi
        if command -v mysql >/dev/null; then
          systemctl is-active --quiet mysql && echo "âœ… MySQL: ACTIVE" || echo "âŒ MySQL: INACTIVE"
        fi
        
        # Verify blog files
        if [ -f "$BLOG_DIR/index.php" ]; then
          echo "âœ… Blog files: DEPLOYED"
        else
          echo "âŒ Blog files: MISSING"
        fi
        
        # Cleanup
        rm -f /tmp/blog-app.tar.gz
        rm -rf /tmp/src
        
        echo "âœ… Smart deployment completed successfully!"
        EOF

    - name: ğŸ” Verify Deployment
      run: |
        INSTANCE_IP="${{ needs.smart-resource-management.outputs.instance-ip }}"
        
        echo "ğŸ” Verifying deployment..."
        
        # Wait for services to stabilize
        echo "â³ Waiting for services to stabilize..."
        sleep 15
        
        # Test blog accessibility
        max_attempts=6
        attempt=1
        
        while [ $attempt -le $max_attempts ]; do
          echo "ğŸŒ Attempt $attempt/$max_attempts: Testing http://$INSTANCE_IP/blog"
          
          if curl -f -s --max-time 10 "http://$INSTANCE_IP/blog" >/dev/null 2>&1; then
            echo "âœ… Blog is accessible!"
            
            # Get a preview of the blog content
            echo "ğŸ“„ Blog content preview:"
            curl -s "http://$INSTANCE_IP/blog" | head -20 | grep -E "(title|<h1|Blog)" || echo "Content retrieved"
            break
          else
            echo "âŒ Blog not accessible yet (attempt $attempt/$max_attempts)"
            
            if [ $attempt -eq $max_attempts ]; then
              echo "âŒ Blog accessibility verification failed"
              
              # Debug information
              echo "ğŸ”§ Debug information:"
              ssh -i private_key.pem -o StrictHostKeyChecking=no ubuntu@$INSTANCE_IP "
                echo 'Service Status:'
                sudo systemctl status apache2 --no-pager -l | head -10
                echo ''
                echo 'Blog Directory:'
                ls -la /var/www/html/blog/ | head -5
                echo ''
                echo 'Apache Error Log:'
                sudo tail -5 /var/log/apache2/error.log 2>/dev/null || echo 'No Apache errors'
                echo ''
                echo 'Network Test:'
                curl -I http://localhost/blog 2>/dev/null || echo 'Local HTTP test failed'
              "
              
              echo ""
              echo "âš ï¸ The blog might still be accessible but verification failed."
              echo "   This could be due to:"
              echo "   - Temporary service startup delays"
              echo "   - Firewall/security group configuration"
              echo "   - Apache configuration issues"
              
              # Don't fail the job for accessibility issues
              echo "Continuing despite verification failure..."
              break
            fi
            
            sleep 20
          fi
          ((attempt++))
        done

    - name: ğŸ§¹ Cleanup
      if: always()
      run: |
        rm -f private_key.pem blog-app.tar.gz

    - name: ğŸ“‹ Deployment Summary
      run: |
        echo "ğŸ‰ Smart Deployment Summary"
        echo "=================================================="
        echo "ğŸ”§ Used existing resources: ${{ needs.smart-resource-management.outputs.use-existing }}"
        echo "ğŸ“Š Instance ID: ${{ needs.smart-resource-management.outputs.instance-id }}"
        echo "ğŸŒ Blog URL: http://${{ needs.smart-resource-management.outputs.instance-ip }}/blog"
        echo "ğŸ  Server Status: http://${{ needs.smart-resource-management.outputs.instance-ip }}"
        echo "ğŸ–¥ï¸ SSH Access: ssh -i key.pem ubuntu@${{ needs.smart-resource-management.outputs.instance-ip }}"
        echo "ğŸ·ï¸ Previous State: ${{ needs.smart-resource-management.outputs.instance-state }} â†’ running"
        echo "=================================================="
        echo ""
        echo "âœ… Smart resource management completed successfully!"
        echo "   - Existing instances were detected and reused"
        echo "   - Stopped instances were automatically started" 
        echo "   - No unnecessary resources were created"
        echo "   - Application was deployed with smart service management"