name: ğŸš€ Smart Deploy to Existing Infrastructure

on:
  push:
    branches: [ main ]
    paths: 
      - 'src/**'
      - 'terraform/**'
  workflow_dispatch:
    inputs:
      force_new_resources:
        description: 'Force creation of new resources instead of using existing'
        required: false
        default: false
        type: boolean

env:
  AWS_REGION: eu-west-1
  TERRAFORM_VERSION: 1.6.6

jobs:
  detect-and-deploy:
    name: ğŸ” Detect Resources & Deploy
    runs-on: ubuntu-latest
    
    steps:
    - name: ğŸ“¥ Checkout Repository
      uses: actions/checkout@v4

    - name: ğŸ”§ Setup Terraform
      uses: hashicorp/setup-terraform@v3
      with:
        terraform_version: ${{ env.TERRAFORM_VERSION }}
        terraform_wrapper: false

    - name: ğŸ” Configure AWS Credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}

    - name: ğŸ” Detect Existing Resources
      id: detect
      run: |
        echo "Detecting existing AWS resources..."
        
        # Look for existing instances
        EXISTING_INSTANCES=$(aws ec2 describe-instances \
          --filters "Name=tag:Project,Values=simple-blog" "Name=instance-state-name,Values=running" \
          --query 'Reservations[*].Instances[*].[InstanceId,Tags[?Key==`Name`].Value|[0],PublicIpAddress,VpcId,SubnetId,SecurityGroups[0].GroupId,KeyName]' \
          --output text 2>/dev/null || echo "")
        
        if [ -n "$EXISTING_INSTANCES" ] && [ "${{ github.event.inputs.force_new_resources }}" != "true" ]; then
          # Parse the first running instance
          read -r INSTANCE_ID INSTANCE_NAME PUBLIC_IP VPC_ID SUBNET_ID SG_ID KEY_NAME <<< "$EXISTING_INSTANCES"
          
          echo "Found existing running instance:"
          echo "  Instance ID: $INSTANCE_ID"
          echo "  Name: $INSTANCE_NAME"
          echo "  Public IP: $PUBLIC_IP"
          echo "  VPC: $VPC_ID"
          echo "  Subnet: $SUBNET_ID"
          echo "  Security Group: $SG_ID"
          echo "  Key Name: $KEY_NAME"
          
          # Set outputs for next steps
          echo "use_existing=true" >> $GITHUB_OUTPUT
          echo "instance_id=$INSTANCE_ID" >> $GITHUB_OUTPUT
          echo "instance_ip=$PUBLIC_IP" >> $GITHUB_OUTPUT
          echo "vpc_id=$VPC_ID" >> $GITHUB_OUTPUT
          echo "subnet_id=$SUBNET_ID" >> $GITHUB_OUTPUT
          echo "security_group_id=$SG_ID" >> $GITHUB_OUTPUT
          echo "key_name=$KEY_NAME" >> $GITHUB_OUTPUT
          
          # Create terraform.tfvars for existing resources
          cat > terraform/terraform.tfvars << EOF
        # Auto-generated for existing resources
        use_existing_resources = true
        existing_instance_id = "$INSTANCE_ID"
        existing_vpc_id = "$VPC_ID"
        existing_subnet_id = "$SUBNET_ID"
        existing_security_group_id = "$SG_ID"
        existing_key_pair_name = "$KEY_NAME"
        
        # Project configuration
        aws_region = "eu-west-1"
        environment = "production"
        project_name = "simple-blog"
        terraform_state_bucket = "${{ secrets.TERRAFORM_STATE_BUCKET }}"
        github_repo_url = "${{ github.server_url }}/${{ github.repository }}.git"
        EOF
          
        else
          echo "No existing running instances found or forced new resources"
          echo "use_existing=false" >> $GITHUB_OUTPUT
          
          # Create terraform.tfvars for new resources
          cat > terraform/terraform.tfvars << EOF
        # Auto-generated for new resources
        use_existing_resources = false
        
        # Project configuration
        aws_region = "eu-west-1"
        environment = "production"
        project_name = "simple-blog"
        terraform_state_bucket = "${{ secrets.TERRAFORM_STATE_BUCKET }}"
        github_repo_url = "${{ github.server_url }}/${{ github.repository }}.git"
        EOF
        fi

    - name: ğŸš€ Terraform Init
      working-directory: ./terraform
      run: |
        terraform init \
          -backend-config="bucket=${{ secrets.TERRAFORM_STATE_BUCKET }}" \
          -backend-config="key=blog-app/terraform.tfstate" \
          -backend-config="region=${{ env.AWS_REGION }}"

    - name: âœ… Terraform Plan
      working-directory: ./terraform
      run: terraform plan -out=tfplan

    - name: ğŸ—ï¸ Terraform Apply
      working-directory: ./terraform
      run: terraform apply -auto-approve tfplan

    - name: ğŸ“¤ Get Infrastructure Outputs
      id: terraform-outputs
      working-directory: ./terraform
      run: |
        echo "instance_ip=$(terraform output -raw instance_public_ip)" >> $GITHUB_OUTPUT
        echo "instance_id=$(terraform output -raw instance_id)" >> $GITHUB_OUTPUT
        echo "ssh_key_name=$(terraform output -raw ssh_key_name)" >> $GITHUB_OUTPUT

    - name: ğŸ”‘ Setup SSH Key
      run: |
        echo "${{ secrets.SSH_PRIVATE_KEY }}" > private_key.pem
        chmod 600 private_key.pem

    - name: â³ Wait for Instance (New Instances Only)
      if: steps.detect.outputs.use_existing == 'false'
      run: |
        echo "Waiting for new instance to be ready..."
        instance_ip="${{ steps.terraform-outputs.outputs.instance_ip }}"
        max_attempts=30
        attempt=1
        
        while [ $attempt -le $max_attempts ]; do
          echo "Attempt $attempt/$max_attempts: Checking instance readiness..."
          
          if timeout 15 ssh -i private_key.pem -o StrictHostKeyChecking=no -o ConnectTimeout=10 ubuntu@$instance_ip "echo 'SSH ready'" 2>/dev/null; then
            if ssh -i private_key.pem -o StrictHostKeyChecking=no ubuntu@$instance_ip "test -f /var/log/userdata-complete" 2>/dev/null; then
              echo "âœ… New instance is ready!"
              break
            else
              echo "Userdata still running..."
            fi
          else
            echo "SSH not ready yet..."
          fi
          
          sleep 30
          ((attempt++))
        done

    - name: ğŸ¯ Quick Ready Check (Existing Instances)
      if: steps.detect.outputs.use_existing == 'true'
      run: |
        echo "Checking existing instance readiness..."
        instance_ip="${{ steps.terraform-outputs.outputs.instance_ip }}"
        
        if timeout 10 ssh -i private_key.pem -o StrictHostKeyChecking=no ubuntu@$instance_ip "echo 'SSH working'" 2>/dev/null; then
          echo "âœ… Existing instance is accessible"
          
          # Quick service check
          ssh -i private_key.pem -o StrictHostKeyChecking=no ubuntu@$instance_ip "
            echo 'Service Status:'
            systemctl is-active apache2 2>/dev/null && echo 'Apache: RUNNING' || echo 'Apache: STOPPED'
            systemctl is-active mysql 2>/dev/null && echo 'MySQL: RUNNING' || echo 'MySQL: STOPPED'
          "
        else
          echo "âŒ Cannot connect to existing instance"
          exit 1
        fi

    - name: ğŸš€ Deploy Application
      run: |
        echo "Deploying application to instance..."
        instance_ip="${{ steps.terraform-outputs.outputs.instance_ip }}"
        
        # Create deployment package
        tar -czf blog-app.tar.gz src/
        
        # Upload to server
        scp -i private_key.pem -o StrictHostKeyChecking=no blog-app.tar.gz ubuntu@$instance_ip:/tmp/
        
        # Deploy application with smart service management
        ssh -i private_key.pem -o StrictHostKeyChecking=no ubuntu@$instance_ip << 'EOF'
        set -e
        
        echo "=== Smart Application Deployment ==="
        
        # Extract application
        cd /tmp
        tar -xzf blog-app.tar.gz
        
        # Ensure blog directory exists
        BLOG_DIR="/var/www/html/blog"
        sudo mkdir -p "$BLOG_DIR"
        
        # Deploy files
        sudo cp -r src/* "$BLOG_DIR/"
        sudo chown -R www-data:www-data "$BLOG_DIR"
        sudo chmod -R 755 "$BLOG_DIR"
        echo "âœ… Files deployed"
        
        # Smart service management
        echo "=== Managing Services ==="
        
        # Check and start Apache
        if ! systemctl is-active --quiet apache2; then
          echo "Starting Apache..."
          sudo systemctl start apache2
          sudo systemctl enable apache2
        else
          echo "Apache already running, reloading..."
          sudo systemctl reload apache2
        fi
        
        # Check and start MySQL
        if ! systemctl is-active --quiet mysql; then
          echo "Starting MySQL..."
          sudo systemctl start mysql
          sudo systemctl enable mysql
        else
          echo "MySQL already running"
        fi
        
        # Smart database setup
        if [ -f "$BLOG_DIR/database.sql" ]; then
          echo "Setting up database..."
          # Try different MySQL access methods
          for method in "mysql -u root -p'${{ secrets.MYSQL_ROOT_PASSWORD }}'" "mysql -u root -pRootSecurePassword123!" "mysql -u root"; do
            if eval "$method -e 'SELECT 1'" >/dev/null 2>&1; then
              echo "Database connection successful"
              eval "$method < $BLOG_DIR/database.sql" 2>/dev/null || echo "Database setup attempted"
              break
            fi
          done
        fi
        
        # Final service verification
        echo "=== Final Status ==="
        systemctl is-active apache2 && echo "âœ… Apache: ACTIVE" || echo "âŒ Apache: INACTIVE"
        systemctl is-active mysql && echo "âœ… MySQL: ACTIVE" || echo "âŒ MySQL: INACTIVE"
        
        # Clean up
        rm -f /tmp/blog-app.tar.gz /tmp/src -rf
        
        echo "âœ… Smart deployment completed!"
        EOF

    - name: ğŸ” Verify Deployment
      run: |
        instance_ip="${{ steps.terraform-outputs.outputs.instance_ip }}"
        
        echo "Verifying deployment..."
        sleep 10
        
        max_attempts=5
        attempt=1
        
        while [ $attempt -le $max_attempts ]; do
          if curl -f -s --max-time 10 "http://$instance_ip/blog" >/dev/null; then
            echo "âœ… Blog is accessible!"
            break
          else
            echo "Attempt $attempt/$max_attempts: Blog not yet accessible"
            if [ $attempt -eq $max_attempts ]; then
              echo "âŒ Blog verification failed"
              # Show debug info
              ssh -i private_key.pem -o StrictHostKeyChecking=no ubuntu@$instance_ip "
                echo 'Debug Info:'
                sudo systemctl status apache2 --no-pager -l | head -10
                ls -la /var/www/html/blog/ | head -5
                sudo tail -5 /var/log/apache2/error.log 2>/dev/null || echo 'No Apache errors'
              "
              exit 1
            fi
            sleep 15
          fi
          ((attempt++))
        done

    - name: ğŸ§¹ Cleanup
      if: always()
      run: |
        rm -f private_key.pem blog-app.tar.gz
        rm -f terraform/tfplan

    - name: ğŸ“‹ Deployment Summary
      run: |
        echo "ğŸ‰ Deployment Summary"
        echo "===================="
        echo "ğŸ”§ Used existing resources: ${{ steps.detect.outputs.use_existing }}"
        echo "ğŸŒ Blog URL: http://${{ steps.terraform-outputs.outputs.instance_ip }}/blog"
        echo "ğŸ  Server: http://${{ steps.terraform-outputs.outputs.instance_ip }}"
        echo "ğŸ“Š Instance: ${{ steps.terraform-outputs.outputs.instance_id }}"
        echo "ğŸ—ï¸  SSH: ssh -i key.pem ubuntu@${{ steps.terraform-outputs.outputs.instance_ip }}"
        echo "===================="